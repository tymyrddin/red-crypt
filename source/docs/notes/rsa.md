# RSA puzzling

RSA encryption is an asymmetric algorithm that uses very large integers as both keys and messages, and the
**modular exponentiation** as the primary mathematical operator for encryption and decryption. The algorithm is simple to understand and [relatively easy to implement](https://github.com/tymyrddin/scripts-modern-ciphers/tree/main/rsa): 

1. Key generation
2. Key distribution
3. Encryption
4. Decryption

Message encryption is done with a **Public Key**, and message decryption is done with a **Private Key** – parameters ($p$, $q$, $d$) generated together with the **Public Key**.
The private key is known only to the user, and the public key can be made known to anyone who wishes to send an encrypted message to the person with the corresponding private key.

## Key generation

To [generate an RSA key pair](https://github.com/tymyrddin/scripts-modern-ciphers/blob/main/rsa/generate_public_private_keys.py):

1. Pick two primes $p$ and $q$
2. Using $p$ and $q$, calculate modulus $n = p × q$ and its **Euler's totient** $ϕ(n) = (p−1) × (q−1)$
3. Choose the public exponent $e$ with $gcd(e,ϕ(n)) = 1$
4. sing the Extended Euclidean algorithm, compute the invert $d$ of $e \mod n$: $d ≡ e^{−1} \mod (ϕ(n))$, which is the private exponent.
5. Public key: $n, e$
6. Private key: $n, d$
7. Choose a message $m$ to convert into integers
8. Encrypt this plaintext $m$ and receive a ciphertext $c ≡ m^e \mod n$
9. Decrypt a ciphertext $c$ with $m ≡ c^d \mod n$

## Trapdoor function

All public-key systems are based on the concept of trapdoor functions, simple to compute in one direction and computationally hard to reverse without knowledge of some special information called the trapdoor. In RSA, the trapdoor function is based on the hardness of factoring integers. Except in certain cases, there exists no efficient algorithm for factoring huge integers.

The RSA trapdoor permutation is the core algorithm behind RSA-based encryption and signatures. Given a modulus $n$ and number $e$, the public exponent, the RSA trapdoor permutation transforms a number $x$ from the set $Z_n^*$ into a number $y = x^e \mod (n). 

When using the RSA trapdoor permutation to encrypt, the modulus $n$ and the exponent $e$ make up the RSA public key.

In order to get $x$ back from $y$, $d$ is used:

\begin{align} y^d mod n = (x^e)^d mod n = x^{ed} mod n = x \end{align}

Because $d$ is the trapdoor that allows decryption, it is part of the private key in the RSA key pair, and, unlike the public key, should always be kept secret. It is also called the secret exponent.

$d$ is not just any number; it is the number such that $e$ multiplied by $d$ is equivalent to 1, and therefore such that $x^{ed} mod n = x$ for any $x$. 

We must have $ed = 1 mod φ(n)$ in order to get $x^{ed} = x 1 = x$ and to decrypt the message correctly. It is necessary to compute $modulo φ(n)$ and not $modulo n$ because exponents behave like the indexes of elements of $Z^n$ rather than as the elements themselves. Because $Z^n$ has $φ(n)$ elements, the index must be less than $φ(n)$.

Finding $φ(n)$ for an RSA modulus n is equivalent to breaking RSA, because the secret exponent $d$ can easily be derived from $φ(n)$ and $e$, by computing $e$'s inverse. Therefore, $p$ and $q$ must also be kept secret, since knowing $p$ or $q$ gives $φ(n)$ by computing $(p-1)(q-1) = φ(n)$.

## Common plaintext attacks

These include short message attacks in which an attacker knows some blocks of plaintext and tries to decode cipher text with the help of that; cycling attacks, in which the attacker thinks that the cipher text has been generated by using some permutation and uses all possible permutations of plain text to decipher the cipher text by 'cycling' the permutations; and sometimes it happens that the plain text is the same as the cipher text after encryption. 

## Chosen ciphertext attack

An attack in which an attacker uses the Extended Euclidean Algorithm to retrieve the plaintext based on ciphertext. 

## Factorisation attacks

If an attacker is able to know $p$ and $q$ using $n$, then it is possible to figure out the value of the private key.

## Wiener's attack

Small value for $e$ can lead to potential attacks known as attacks on the encryption key, such as Wiener’s
attack on RSA with low private exponents.

Wiener's attack is an attack on RSA that uses continued fractions to find the private exponent $d$ when it is small (less than $\frac{1}{3} \sqrt[4]{n}$). We know that when picking the public exponent $e$ to be a small number and calculating its inverse $d ≡ e^{−1} \mod ϕ(n)$.

Suppose we have the public key $(n,e)$, this attack will determine $d$:

1. Convert the fraction $\frac{e}{n}$ into a continued fraction $[a_0;a_1,a_2,…,a_{k−2},a_{k−1},a_k]$.
2. Iterate over each convergent in the continued fraction: 

\begin{align} \frac{a_0}{1}, a_0 + \frac{1}{a_1}, a_0 + \frac{1}{a_1 + \frac{1}{a_2}} ... , a_0 + \frac{1}{a_1 + \frac{1}{a_{k-2} +  \frac{1}{a_{k-1}}}} \end{align}

3. Check if the convergent is $\frac{k}{d}$ by:
   * Setting the numerator to be $k$ and denominator to be $d$ 
   * Check if $d$ is odd, if not, move on to the next convergent 
   * Check if $ed ≡ 1 \mod(k)$, if not, move on to the next convergent 
   * Set $ϕ(n) = \frac{ed−1}{k}$ and find the roots of the polynomial $x^2 − (n−ϕ(n)+1)x + n$
   * If the roots of the polynomial are integers, then we've found $d$ (If not, move on to the next convergent).

If all convergents have been tried, and none of them work, then the given RSA parameters are not vulnerable to Wiener's attack.

## Boneh-Durfee attack

The Boneh-Durfee attack is an extension of Wiener's attack. That is, it also attacks on low private component $d$ with a further relaxed condition. If $d$ satisfies:

Then it is possible to use the Boneh-Durfee attack to retrive $d$.

## Attack on decryption key 

In the **revealed decryption exponent attack**, an attacker somehow guessed decryption key $d$, putting not only the ciphertext generated by encryption and the plaintext with corresponding encryption key in danger, also future messages are at risk. 

A **low decryption exponent attack** is the result of a too low value of $d$ (smaller than $2^{16} + 1$).

## RootMe challenges

* [RSA Factorisation](../asymmetric/factorisation.md)
* [RSA Decipher oracle](../asymmetric/oracle.md)
* [RSA Corrupted key 1](../asymmetric/corrupted-key1.md)
* [RSA Continued fractions](../asymmetric/fractions.md)
* [RSA Common modulus](../asymmetric/modulus.md)
* [RSA Padding](../asymmetric/padding.md)
* [RSA Signature](../asymmetric/signature.md)
* [RSA Corrupted key 2](../asymmetric/corrupted-key2.md)
* [RSA Corrupted key 3](../asymmetric/corrupted-key3.md)
* [RSA Multiple recipients](../asymmetric/multiple-recipients.md)
* [RSA Lee cooper](../asymmetric/lee-cooper.md)

## Remediations

* Pad the plain text before encrypting.
* Make sure $n$ is a large number (at least 300 digits). 
* Minimally use an $e$ of $2^16 + 1$
* Use a $d$ larger than $2^16 + 1$